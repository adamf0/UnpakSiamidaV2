
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>helper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">UnpakSiamida/common/helper/helper.go (20.2%)</option>
				
				<option value="file1">UnpakSiamida/common/helper/jwt.go (0.0%)</option>
				
				<option value="file2">UnpakSiamida/common/helper/security.go (50.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package helper

import (
        "fmt"
        "html"
        "regexp"
        "strconv"
        "strings"
        "time"
)

var (
        reUnpakEmail = regexp.MustCompile(
                `^[A-Za-z0-9](?:[A-Za-z0-9._-]*[A-Za-z0-9])?@unpak\.ac\.id$`,
        )

        reUUIDv4 = regexp.MustCompile(
                `^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-4[a-fA-F0-9]{3}-[89abAB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}$`,
        )

        rePlus        = regexp.MustCompile(`\+`)
        reDoubleSep   = regexp.MustCompile(`(\.\.|__|--)`)
        reWhitespace  = regexp.MustCompile(`\s`)
        reURLEncoded  = regexp.MustCompile(`%[0-9A-Fa-f]{2}`)
        reURLEncoded2 = regexp.MustCompile(`%25[0-9A-Fa-f]{2}`)
        reNonASCII    = regexp.MustCompile(`[^\x20-\x7F]`)
)

func IsValidUnpakEmail(email string) bool <span class="cov8" title="1">{
        if len(email) &gt; 254 </span><span class="cov8" title="1">{ //[note] dalam pemantauan
                return false
        }</span>

        // 1. Base pattern
        <span class="cov8" title="1">reg := regexp.MustCompile(reUnpakEmail.String())

        if !reg.MatchString(email) </span><span class="cov8" title="1">{
                return false
        }</span>

        // 2. No plus (+)
        <span class="cov8" title="1">if regexp.MustCompile(rePlus.String()).MatchString(email) </span><span class="cov0" title="0">{
                return false
        }</span>

        // 3. Double separator
        <span class="cov8" title="1">if regexp.MustCompile(reDoubleSep.String()).MatchString(email) </span><span class="cov8" title="1">{
                return false
        }</span>

        // 4. No whitespace
        <span class="cov8" title="1">if regexp.MustCompile(reWhitespace.String()).MatchString(email) </span><span class="cov0" title="0">{
                return false
        }</span>

        // 5. No URL-encoded chars
        <span class="cov8" title="1">if regexp.MustCompile(reURLEncoded.String()).MatchString(email) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if regexp.MustCompile(reURLEncoded2.String()).MatchString(email) </span><span class="cov0" title="0">{
                return false
        }</span>

        // 6. No non-ASCII
        <span class="cov8" title="1">if regexp.MustCompile(reNonASCII.String()).MatchString(email) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func ValidateUnpakEmail(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Email cannot be blank")
        }</span>

        <span class="cov0" title="0">email, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("Email invalid type")
        }</span>

        <span class="cov0" title="0">if !IsValidUnpakEmail(email) </span><span class="cov0" title="0">{
                return fmt.Errorf("Email is not valid unpak.ac.id")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ValidateUUIDv4(value interface{}) error <span class="cov8" title="1">{
        s, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("UUID invalid type")
        }</span>

        <span class="cov8" title="1">s = strings.TrimSpace(s)

        // Cek null padding ASCII ( \x00 )
        if strings.Contains(s, "\x00") </span><span class="cov0" title="0">{
                return fmt.Errorf("UUID contains invalid null padding")
        }</span>

        <span class="cov8" title="1">if len(s) != 36 </span><span class="cov8" title="1">{
                return fmt.Errorf("UUID must be a valid UUIDv4 format")
        }</span>

        // format regex UUID v4
        <span class="cov8" title="1">matched := regexp.MustCompile(reUUIDv4.String()).MatchString(s)
        if !matched </span><span class="cov0" title="0">{
                return fmt.Errorf("UUID must be a valid UUIDv4 format")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ValidateFakultasUnit(value interface{}, level interface{}) error <span class="cov0" title="0">{
        levelStr, ok := level.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("level invalid type")
        }</span>

        <span class="cov0" title="0">var s string
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                s = strings.TrimSpace(v)</span>
        case *string:<span class="cov0" title="0">
                if v != nil </span><span class="cov0" title="0">{
                        s = strings.TrimSpace(*v)
                }</span>
        case nil:<span class="cov0" title="0">
                s = ""</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("FakultasUnit invalid type")</span>
        }

        <span class="cov0" title="0">if levelStr == "fakultas" &amp;&amp; s == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("FakultasUnit cannot be blank")
        }</span>
        <span class="cov0" title="0">if (levelStr == "admin" || levelStr == "user") &amp;&amp; s != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("FakultasUnit required to be blank")
        }</span>

        <span class="cov0" title="0">if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return ValidateUUIDv4(s)</span>
}

func ValidateParent(value interface{}) error <span class="cov0" title="0">{
        var s string

        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                s = strings.TrimSpace(v)</span>

        case *string:<span class="cov0" title="0">
                if v != nil </span><span class="cov0" title="0">{
                        s = strings.TrimSpace(*v)
                }</span>

        case nil:<span class="cov0" title="0">
                return nil</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("Parent invalid type")</span>
        }

        <span class="cov0" title="0">if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return ValidateUUIDv4(value)</span>
}

func ValidateLevel(value interface{}) error <span class="cov0" title="0">{
        val, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("level invalid type")
        }</span>

        <span class="cov0" title="0">validLevels := map[string]struct{}{
                "admin":    {},
                "user":     {},
                "fakultas": {},
        }

        if _, exists := validLevels[val]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("level not exist")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ParseInt64(s string) (int64, error) <span class="cov0" title="0">{
        val, err := strconv.ParseInt(s, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                if numErr, ok := err.(*strconv.NumError); ok </span><span class="cov0" title="0">{
                        switch numErr.Err </span>{
                        case strconv.ErrRange:<span class="cov0" title="0">
                                return 0, fmt.Errorf("Number out of range")</span>
                        case strconv.ErrSyntax:<span class="cov0" title="0">
                                return 0, fmt.Errorf("Must be a number")</span>
                        }
                }
                <span class="cov0" title="0">return 0, fmt.Errorf("Invalid number")</span>
        }
        <span class="cov0" title="0">return val, nil</span>
}

func IsValidTugas(tugas string) bool <span class="cov0" title="0">{
        switch tugas </span>{
        case
                "auditor1",
                "auditor2":<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func IsValidTypeGenerate(tipe string) bool <span class="cov0" title="0">{
        switch tipe </span>{
        case
                "renstra",
                "dokumen_tambahan":<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func StringValue(s *string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *s</span>
}
func StringHtmlValue(v *string) string <span class="cov0" title="0">{
        if v == nil || *v == "" </span><span class="cov0" title="0">{
                return "-"
        }</span>
        <span class="cov0" title="0">return html.EscapeString(*v)</span>
}
func Status(v *uint) string <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return "-"
        }</span>
        <span class="cov0" title="0">if *v == 1 </span><span class="cov0" title="0">{
                return "Ya"
        }</span>
        <span class="cov0" title="0">return "Tidak"</span>
}

var bulanID = []string{
        "",
        "Januari", "Februari", "Maret", "April", "Mei", "Juni",
        "Juli", "Agustus", "September", "Oktober", "November", "Desember",
}

var locWIB, _ = time.LoadLocation("Asia/Jakarta")

func formatWIB(t time.Time) string <span class="cov0" title="0">{
        t = t.In(locWIB)

        return fmt.Sprintf(
                "%02d %s %d %02d:%02d:%02d WIB",
                t.Day(),
                bulanID[int(t.Month())],
                t.Year(),
                t.Hour(),
                t.Minute(),
                t.Second(),
        )
}</span>

func FTime(t time.Time) string <span class="cov0" title="0">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return "-"
        }</span>
        <span class="cov0" title="0">return formatWIB(t)</span>
}

func FTimeStr(v *string) string <span class="cov0" title="0">{
        if v == nil || *v == "" </span><span class="cov0" title="0">{
                return "-"
        }</span>

        <span class="cov0" title="0">layouts := []string{
                time.RFC3339,
                "2006-01-02 15:04:05",
                "2006-01-02",
        }

        for _, layout := range layouts </span><span class="cov0" title="0">{
                if t, err := time.Parse(layout, *v); err == nil </span><span class="cov0" title="0">{
                        return formatWIB(t)
                }</span>
        }

        <span class="cov0" title="0">return *v</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package helper

import (
        "time"
        "github.com/golang-jwt/jwt/v5"
)

var jwtSecret = []byte("secret")

type JWTService struct {
        Secret []byte
}

func GenerateToken(sid string) (string, string, error) <span class="cov0" title="0">{
        // Access token (15 menit)
        accessClaims := jwt.MapClaims{
                "sid": sid,
                "exp": time.Now().Add(1 * 24 * time.Hour).Unix(),
        }
        accessJWT := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
        accessTokenStr, err := accessJWT.SignedString(jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Refresh token (7 hari)
        <span class="cov0" title="0">refreshClaims := jwt.MapClaims{
                "sid": sid,
                "exp": time.Now().Add(14 * 24 * time.Hour).Unix(),
        }
        refreshJWT := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
        refreshTokenStr, err := refreshJWT.SignedString(jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">return accessTokenStr, refreshTokenStr, nil</span>
}

// func NewJWTService() *JWTService {
//         return &amp;JWTService{
//                 Secret: jwtSecret,
//         }
// }

// func (s *JWTService) ValidateToken(authHeader string) (jwt.MapClaims, error) {
//         if authHeader == "" {
//                 return nil, errors.New("authorization header missing")
//         }

//         parts := strings.Split(authHeader, " ")
//         if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" {
//                 return nil, errors.New("authorization header format must be Bearer {token}")
//         }

//         tokenStr := parts[1]

//         token, err := jwt.Parse(tokenStr, func(t *jwt.Token) (interface{}, error) {
//                 if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok {
//                         return nil, errors.New("invalid signing method")
//                 }
//                 return s.Secret, nil
//         })

//         if err != nil || !token.Valid {
//                 if err != nil {
//                         return nil, errors.New("invalid token: " + err.Error())
//                 }
//                 return nil, errors.New("invalid token")
//         }

//         claims, ok := token.Claims.(jwt.MapClaims)
//         if !ok {
//                 return nil, errors.New("invalid token claims")
//         }

//         if exp, ok := claims["exp"].(float64); ok &amp;&amp; int64(exp) &lt; time.Now().Unix() {
//                 return nil, errors.New("token expired")
//         }

//         return claims, nil
// }</pre>
		
		<pre class="file" id="file2" style="display: none">package helper

import (
        "errors"
        "html"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "unicode/utf8"

        validation "github.com/go-ozzo/ozzo-validation/v4"
        "golang.org/x/text/unicode/norm"
)

// -----------------------------
// Lists (abridged but extensive)
// -----------------------------
var (
        blacklistTags = []string{
                "html", "head", "body", "title", "meta", "base", "link", "style", "script", "noscript", "template",
                "form", "input", "textarea", "select", "option", "button", "datalist",
                "img", "picture", "source", "video", "audio", "track", "canvas",
                "iframe", "frame", "frameset", "object", "embed", "param", "applet",
                "svg", "g", "path", "rect", "circle", "ellipse", "line", "polyline", "polygon", "use", "defs", "symbol", "image", "text", "tspan",
                "math", "mrow", "mi", "mn", "mo", "mtext", "mglyph", "ms", "mtable", "mtr", "mtd", "annotation",
                "iframe", "object", "embed", "isindex", "layer", "ilayer", "noframes", "blink", "xmp", "plaintext",
        }
        // protoList = []string{
        //         "javascript:", "data:", "vbscript:", "file:", "filesystem:", "blob:",
        //         "about:", "chrome:", "chrome-extension:", "moz-extension:", "view-source:",
        // }
        dangerousProtoRe = regexp.MustCompile(`(?i)\b(javascript|data|vbscript|file|filesystem|blob|about|chrome|chrome-extension|moz-extension|view-source):`)
        // sqlKeywordRe     = regexp.MustCompile(`(?i)\b(select|union|insert|update|delete|drop|sleep|benchmark|or\s+1=1)\b`)
        lfiRe        = regexp.MustCompile(`(?i)(\.\./|\.\.\\|/etc/passwd|boot.ini|win.ini|.env)`)
        asciiAllowRe = regexp.MustCompile(
                `^[A-Za-z0-9 .,:;'"()\[\]{}+\-*/=&lt;&gt;&amp;!?%#@_~^]*$`,
        )
        cssPatterns = []string{
                `(?i)expression\s*\(`,        // expression(
                `(?i)-moz-binding\s*:`,       // -moz-binding
                `(?i)url\s*\(\s*data:`,       // url(data:
                `(?i)url\s*\(\s*javascript:`, // url(javascript:
                `(?i)@import\s+`,             // @import
        }
        specialPatterns = []string{
                `(?i)&lt;!doctype`,   // doctype
                `(?i)&lt;!--`,        // comment
                `(?i)&lt;!\[CDATA\[`, // cdata
                `\x00`,            // null byte
                `%00`,             // url-encoded null
                `\\u0000`,         // escaped null
                `%3c`,             // %3c == &lt;
                `%3e`,             // %3e == &gt;
                `(?i)utf-7`,       // UTF-7 marker attempts
        }
        eventAttrPattern = regexp.MustCompile(`(?i)\bon[a-z]+\s*=`)
        anyTagRe         = regexp.MustCompile(`(?i)&lt;\s*/?\s*[a-z][a-z0-9]*(?:\s+[^&gt;]+)?&gt;`)
        hexEntityRe      = regexp.MustCompile(`&amp;#x([0-9A-Fa-f]+);?`)
        decEntityRe      = regexp.MustCompile(`&amp;#([0-9]+);?`)
        zeroWidthRe      = regexp.MustCompile(string([]rune{
                '\u200B',
                '\u200C',
                '\u200D',
                '\uFEFF',
                '\u2060',
        }))
        latinSafeRe = regexp.MustCompile(
                `^[A-Za-z0-9 .,;:_\-+*/=()!%&amp;@#?$'"&lt;&gt;/\n\r\t]*$`,
        )
        allowedTagsRe = regexp.MustCompile(
                `(?i)&lt;/?(p|b|i|ul|ol|li)\s*&gt;`,
        )

        jsExecRe      = regexp.MustCompile(`(?i)\b(alert|eval|prompt|confirm|settimeout|setinterval|function)\s*\(`)
        jsPrototypeRe = regexp.MustCompile(`(?i)\b(object|array|string|number|regexp)\.prototype\b`)
        domSinkRe     = regexp.MustCompile(`(?i)\b(location|document|window)\.(hash|href|cookie|write)\b`)
        // sqlTimeRe       = regexp.MustCompile(`(?i)\b(waitfor\s+delay|sleep\s*\(|benchmark\s*\()\b`)
        encodedJsCallRe = regexp.MustCompile(`(?i)(alert|eval|prompt|confirm)[^a-z0-9]*\(`)
)

// deprecated
var compiledTagRegex *regexp.Regexp

// -----------------------------
// Decoding helpers
// -----------------------------

// decodeNumericEntities converts both hex (&amp;#xHH;) and decimal (&amp;#DDD;) numeric entities to runes.
func decodeNumericEntities(s string) string <span class="cov8" title="1">{
        s = hexEntityRe.ReplaceAllStringFunc(s, func(m string) string </span><span class="cov0" title="0">{
                parts := hexEntityRe.FindStringSubmatch(m)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        return m
                }</span>
                <span class="cov0" title="0">v, err := strconv.ParseUint(parts[1], 16, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return m
                }</span>
                <span class="cov0" title="0">return string(rune(v))</span>
        })

        <span class="cov8" title="1">s = decEntityRe.ReplaceAllStringFunc(s, func(m string) string </span><span class="cov0" title="0">{
                parts := decEntityRe.FindStringSubmatch(m)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        return m
                }</span>
                <span class="cov0" title="0">v, err := strconv.ParseUint(parts[1], 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return m
                }</span>
                <span class="cov0" title="0">return string(rune(v))</span>
        })

        <span class="cov8" title="1">return s</span>
}

// small helpers to parse hex/dec into rune without importing strconv repeatedly
func fmtSscanfHex(hexStr string, out *rune) (int, error) <span class="cov0" title="0">{
        // parse hex
        var v uint64
        var err error
        v, err = parseUint(hexStr, 16)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">*out = rune(v)
        return 1, nil</span>
}
func fmtSscanfDec(decStr string, out *rune) (int, error) <span class="cov0" title="0">{
        var v uint64
        var err error
        v, err = parseUint(decStr, 10)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">*out = rune(v)
        return 1, nil</span>
}
func parseUint(s string, base int) (uint64, error) <span class="cov0" title="0">{
        // keep import light: use strconv
        return strconvParseUint(s, base)
}</span>
func strconvParseUint(s string, base int) (uint64, error) <span class="cov0" title="0">{
        // wrapper for strconv.ParseUint so imports clear
        return strconv.ParseUint(s, base, 64)
}</span>

func deepDecode(input string) string <span class="cov8" title="1">{

        // 1) HTML entities
        s := html.UnescapeString(input)

        // 2) URL encoding
        if u, err := url.QueryUnescape(s); err == nil </span><span class="cov8" title="1">{
                s = u
        }</span>

        // 3) Numeric entities
        <span class="cov8" title="1">s = decodeNumericEntities(s)

        // 4) Zero-width chars
        s = zeroWidthRe.ReplaceAllString(s, "")

        // 5) Unicode normalization
        s = norm.NFKC.String(s)

        return s</span>
}

// -----------------------------
// Rule: NoXSSFullScanWithDecode
// -----------------------------

// NoXSSFullScanWithDecode returns an ozzo-validation RuleFunc with deep decoding normalization
// and aggressive detection. It returns an error with a short reason.
func NoXSSFullScanWithDecode() validation.RuleFunc <span class="cov8" title="1">{
        var parts []string
        for _, tag := range blacklistTags </span><span class="cov8" title="1">{
                // match &lt;tag or &amp;lt;tag (case-insensitive)
                parts = append(parts, `(?i)&lt;\s*`+regexp.QuoteMeta(tag)+`(\b|[^a-z0-9])`)
                parts = append(parts, `(?i)&amp;lt;\s*`+regexp.QuoteMeta(tag)+`(\b|[^a-z0-9])`)
        }</span>
        <span class="cov8" title="1">compiledTagRegex = regexp.MustCompile(strings.Join(parts, "|"))

        return func(value interface{}) error </span><span class="cov8" title="1">{
                s, _ := value.(string)
                if s == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // 1) pre-normalize decode
                <span class="cov8" title="1">unescaped := deepDecode(s)
                lower := strings.ToLower(unescaped)

                // 2) event attributes
                if eventAttrPattern.MatchString(unescaped) </span><span class="cov8" title="1">{
                        return errors.New("contains event handler attribute (on...=)")
                }</span>
                <span class="cov8" title="1">if jsExecRe.MatchString(lower) </span><span class="cov8" title="1">{
                        return errors.New("javascript execution detected")
                }</span>
                <span class="cov8" title="1">if jsPrototypeRe.MatchString(lower) </span><span class="cov0" title="0">{
                        return errors.New("javascript prototype manipulation detected")
                }</span>
                <span class="cov8" title="1">if domSinkRe.MatchString(lower) </span><span class="cov0" title="0">{
                        return errors.New("dom sink detected")
                }</span>
                // if sqlTimeRe.MatchString(lower) {
                //         return errors.New("sql time-based injection detected")
                // }
                <span class="cov8" title="1">if encodedJsCallRe.MatchString(unescaped) </span><span class="cov0" title="0">{
                        return errors.New("encoded javascript execution detected")
                }</span>

                // 3) dangerous protocols
                // for _, p := range protoList {
                //         if strings.Contains(lower, p) {
                //                 return errors.New("contains dangerous protocol: " + p)
                //         }
                // }
                <span class="cov8" title="1">if dangerousProtoRe.MatchString(lower) </span><span class="cov0" title="0">{
                        return errors.New("dangerous protocol detected")
                }</span>
                // if sqlKeywordRe.MatchString(lower) {
                //         return errors.New("sql keyword detected")
                // }
                <span class="cov8" title="1">if lfiRe.MatchString(lower) </span><span class="cov0" title="0">{
                        return errors.New("lfi pattern detected")
                }</span>
                <span class="cov8" title="1">if !asciiAllowRe.MatchString(unescaped) </span><span class="cov8" title="1">{
                        return errors.New("non-ascii or disallowed character")
                }</span>

                // 4) css constructs
                <span class="cov8" title="1">for _, cp := range cssPatterns </span><span class="cov8" title="1">{
                        if matched, _ := regexp.MatchString(cp, unescaped); matched </span><span class="cov0" title="0">{
                                return errors.New("contains dangerous CSS construct")
                        }</span>
                }

                // 5) special patterns
                <span class="cov8" title="1">for _, sp := range specialPatterns </span><span class="cov8" title="1">{
                        if matched, _ := regexp.MatchString(sp, unescaped); matched </span><span class="cov0" title="0">{
                                return errors.New("contains suspicious token or encoding")
                        }</span>
                }

                // 6) fallback generic tag-like (last resort)
                <span class="cov8" title="1">stripped := allowedTagsRe.ReplaceAllString(unescaped, "")
                if compiledTagRegex.MatchString(stripped) </span><span class="cov8" title="1">{
                        return errors.New("contains disallowed HTML tag")
                }</span>

                // 7) UTF-8 validity check
                <span class="cov8" title="1">if !utf8.ValidString(s) </span><span class="cov0" title="0">{
                        return errors.New("contains invalid UTF-8")
                }</span>

                // 8) Latin-only + safe punctuation
                <span class="cov8" title="1">if !latinSafeRe.MatchString(s) </span><span class="cov0" title="0">{
                        return errors.New("contains non-latin or disallowed characters")
                }</span>

                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
